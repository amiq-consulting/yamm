<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>yamm
API Specification</title>

	<meta name="author" content="">
	<meta name="description" content="yamm API Specification">
	<meta name="generator" content="Specador. Copyright (C) 2005-2016 AMIQ EDA ">
	<meta name="keywords" content="SystemVerilog, HTML Documentation, Specador, AMIQ EDA, yamm API Specification">

	<link href="lib/bootstrap/css/bootstrap.css" rel="stylesheet">
	<link href="css/content.css" rel="stylesheet">
	<link href="css/fonts.css" rel="stylesheet">
	<link href="css/custom.css" rel="stylesheet">
</head>
<body>

	<div class="container-fluid">














	<div class="panel panel-default">
		<div class="panel-heading" data-toggle="collapse" data-target="#macros_undefined_control">
			<h4 class="panel-title">
					Undefined Control Defines  <span class="glyphicon glyphicon-chevron-down"></span>
			</h4>
		</div>
				<ul id="macros_undefined_control" class="list-group panel-collapse collapse in">
				<li class="list-group-item">
					<a name="macro_undefined_control_CDNS_NO_SQR_CHK_SEQ_ID"></a>
					<span class="signature">


<b>		CDNS_NO_SQR_CHK_SEQ_ID
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_INCA"></a>
					<span class="signature">


<b>		INCA
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_MODEL_TECH"></a>
					<span class="signature">


<b>		MODEL_TECH
</b>


					</span>
	<pre class="comment">Any vendor specific defines go here.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_QUESTA"></a>
					<span class="signature">


<b>		QUESTA
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_TODO"></a>
					<span class="signature">


<b>		TODO
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_CB_TRACE_ON"></a>
					<span class="signature">


<b>		UVM_CB_TRACE_ON
</b>


					</span>
	<pre class="comment">The +define+UVM_CB_TRACE_ON setting will instrument the uvm library to emit
messages with message id UVMCB_TRC and UVM_NONE verbosity
notifing add,delete and execution of uvm callbacks. The instrumentation is off by default.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_CMDLINE_NO_DPI"></a>
					<span class="signature">


<b>		UVM_CMDLINE_NO_DPI
</b>


					</span>
	<pre class="comment">Import DPI functions used by the interface to generate the
lists.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_DISABLE_AUTO_ITEM_RECORDING"></a>
					<span class="signature">


<b>		UVM_DISABLE_AUTO_ITEM_RECORDING
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_DISABLE_RESOURCE_CONVERTER"></a>
					<span class="signature">


<b>		UVM_DISABLE_RESOURCE_CONVERTER
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_EMPTY_MACROS"></a>
					<span class="signature">


<b>		UVM_EMPTY_MACROS
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_ENABLE_FIELD_CHECKS"></a>
					<span class="signature">


<b>		UVM_ENABLE_FIELD_CHECKS
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_HDL_NO_DPI"></a>
					<span class="signature">


<b>		UVM_HDL_NO_DPI
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_NO_DEPRECATED"></a>
					<span class="signature">


<b>		UVM_NO_DEPRECATED
</b>


					</span>
	<pre class="comment">Deprecation Control Macros<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_NO_DPI"></a>
					<span class="signature">


<b>		UVM_NO_DPI
</b>


					</span>
	<pre class="comment">Top-level file for DPI subroutines used by UVM.

Tool-specific distribution overlays may be required.

To use UVM without any tool-specific overlay, use +defin+UVM_NO_DPI<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_NO_WAIT_FOR_NBA"></a>
					<span class="signature">


<b>		UVM_NO_WAIT_FOR_NBA
</b>


					</span>
	<pre class="comment">If `included directly in a program block, can't use a non-blocking assign,
but it isn't needed since program blocks are in a seperate region.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_OBJECT_MUST_HAVE_CONSTRUCTOR"></a>
					<span class="signature">


<b>		UVM_OBJECT_MUST_HAVE_CONSTRUCTOR
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_REGEX_NO_DPI"></a>
					<span class="signature">


<b>		UVM_REGEX_NO_DPI
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_REG_NO_INDIVIDUAL_FIELD_ACCESS"></a>
					<span class="signature">


<b>		UVM_REG_NO_INDIVIDUAL_FIELD_ACCESS
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_REPORT_DISABLE_FILE"></a>
					<span class="signature">


<b>		UVM_REPORT_DISABLE_FILE
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_REPORT_DISABLE_FILE_LINE"></a>
					<span class="signature">


<b>		UVM_REPORT_DISABLE_FILE_LINE
</b>


					</span>
	<pre class="comment">`ifndef UVM_USE_FILE_LINE
`define UVM_REPORT_DISABLE_FILE_LINE
`endif<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_REPORT_DISABLE_LINE"></a>
					<span class="signature">


<b>		UVM_REPORT_DISABLE_LINE
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_USE_CALLBACKS_OBJECTION_FOR_TEST_DONE"></a>
					<span class="signature">


<b>		UVM_USE_CALLBACKS_OBJECTION_FOR_TEST_DONE
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_USE_PROCESS_CONTAINER"></a>
					<span class="signature">


<b>		UVM_USE_PROCESS_CONTAINER
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_USE_PROCESS_STATE"></a>
					<span class="signature">


<b>		UVM_USE_PROCESS_STATE
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_USE_RESOURCE_CONVERTER"></a>
					<span class="signature">


<b>		UVM_USE_RESOURCE_CONVERTER
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_UVM_USE_SUSPEND_RESUME"></a>
					<span class="signature">


<b>		UVM_USE_SUSPEND_RESUME
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_VCS"></a>
					<span class="signature">


<b>		VCS
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_undefined_control_YAMM_USE_UVM"></a>
					<span class="signature">


<b>		YAMM_USE_UVM
</b>


					</span>
				</li>
		</ul>

	</div>
	<div class="panel panel-default">
		<div class="panel-heading" data-toggle="collapse" data-target="#macros_defined_control">
			<h4 class="panel-title">
					Defined Control Defines  <span class="glyphicon glyphicon-chevron-down"></span>
			</h4>
		</div>
				<ul id="macros_defined_control" class="list-group panel-collapse collapse in">
				<li class="list-group-item">
					<a name="macro_defined_control_MEM_SIZE"></a>
					<span class="signature">


<b>		MEM_SIZE
</b>


					</span>
	<pre class="comment">Here we define the case number for the allocation_mode and the total MEM_SIZE for the test_bench<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_HDL_MAX_WIDTH"></a>
					<span class="signature">


<b>		UVM_HDL_MAX_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_LINE_WIDTH"></a>
					<span class="signature">


<b>		UVM_LINE_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_MAX_STREAMBITS"></a>
					<span class="signature">


<b>		UVM_MAX_STREAMBITS
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_NUM_LINES"></a>
					<span class="signature">


<b>		UVM_NUM_LINES
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_PACKER_MAX_BYTES"></a>
					<span class="signature">


<b>		UVM_PACKER_MAX_BYTES
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_REG_ADDR_WIDTH"></a>
					<span class="signature">


<b>		UVM_REG_ADDR_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_REG_BYTENABLE_WIDTH"></a>
					<span class="signature">


<b>		UVM_REG_BYTENABLE_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_REG_CVR_WIDTH"></a>
					<span class="signature">


<b>		UVM_REG_CVR_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_UVM_REG_DATA_WIDTH"></a>
					<span class="signature">


<b>		UVM_REG_DATA_WIDTH
</b>


					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_defined_control_YAMM_ADDR_WIDTH"></a>
					<span class="signature">


<b>		YAMM_ADDR_WIDTH
</b>


					</span>
	<pre class="comment">Defines the address bus width<br></pre>
				</li>
		</ul>

	</div>
	<div class="panel panel-default">
		<div class="panel-heading" data-toggle="collapse" data-target="#macros">
			<h4 class="panel-title">
					Defines  <span class="glyphicon glyphicon-chevron-down"></span>
			</h4>
		</div>
				<ul id="macros" class="list-group panel-collapse collapse in">
				<li class="list-group-item">
					<a name="macro_M_FIELD_QDA_ENUM"></a>
					<span class="signature">

	<a name="macro_M_FIELD_QDA_ENUM"></a><b>			`M_FIELD_QDA_ENUM(TYPE, T, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_ARRAY_RESIZE"></a>
					<span class="signature">

	<a name="macro_M_UVM_ARRAY_RESIZE"></a><b>			`M_UVM_ARRAY_RESIZE(ARG, VAL)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_enum_key"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_enum_key"></a><b>			`M_UVM_FIELD_DATA_AA_enum_key(KEY, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_generic"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_generic"></a><b>			`M_UVM_FIELD_DATA_AA_generic(TYPE, KEY, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_int_key"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_int_key"></a><b>			`M_UVM_FIELD_DATA_AA_int_key(KEY, ARG, FLAG)
</b>

					</span>
	<pre class="comment">M_UVM_FIELD_DATA_AA_int_int
----------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_int_string"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_int_string"></a><b>			`M_UVM_FIELD_DATA_AA_int_string(ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_object_int"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_object_int"></a><b>			`M_UVM_FIELD_DATA_AA_object_int(ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_object_string"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_object_string"></a><b>			`M_UVM_FIELD_DATA_AA_object_string(ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_DATA_AA_string_string"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_DATA_AA_string_string"></a><b>			`M_UVM_FIELD_DATA_AA_string_string(ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_QDA_INT"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_QDA_INT"></a><b>			`M_UVM_FIELD_QDA_INT(TYPE, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_QDA_OBJECT"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_QDA_OBJECT"></a><b>			`M_UVM_FIELD_QDA_OBJECT(TYPE, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_QDA_STRING"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_QDA_STRING"></a><b>			`M_UVM_FIELD_QDA_STRING(TYPE, ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_SET_AA_INT_ENUMTYPE"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_SET_AA_INT_ENUMTYPE"></a><b>			`M_UVM_FIELD_SET_AA_INT_ENUMTYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_SET_AA_INT_TYPE"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_SET_AA_INT_TYPE"></a><b>			`M_UVM_FIELD_SET_AA_INT_TYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_SET_AA_OBJECT_TYPE"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_SET_AA_OBJECT_TYPE"></a><b>			`M_UVM_FIELD_SET_AA_OBJECT_TYPE(INDEX_TYPE, ARRAY, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_FIELD_SET_AA_TYPE"></a>
					<span class="signature">

	<a name="macro_M_UVM_FIELD_SET_AA_TYPE"></a><b>			`M_UVM_FIELD_SET_AA_TYPE(INDEX_TYPE, ARRAY_TYPE, ARRAY, RHS, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_QUEUE_RESIZE"></a>
					<span class="signature">

	<a name="macro_M_UVM_QUEUE_RESIZE"></a><b>			`M_UVM_QUEUE_RESIZE(ARG, VAL)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_M_UVM_SARRAY_RESIZE"></a>
					<span class="signature">

	<a name="macro_M_UVM_SARRAY_RESIZE"></a><b>			`M_UVM_SARRAY_RESIZE(ARG, VAL)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_GET_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_GET_IMP"></a><b>			`UVM_BLOCKING_GET_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_GET_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_GET_IMP_SFX"></a><b>			`UVM_BLOCKING_GET_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_GET_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_GET_PEEK_IMP"></a><b>			`UVM_BLOCKING_GET_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_PEEK_IMP"></a><b>			`UVM_BLOCKING_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_PEEK_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_PEEK_IMP_SFX"></a><b>			`UVM_BLOCKING_PEEK_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_PUT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_PUT_IMP"></a><b>			`UVM_BLOCKING_PUT_IMP(imp, TYPE, arg)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------
TLM imp implementations<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_PUT_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_PUT_IMP_SFX"></a><b>			`UVM_BLOCKING_PUT_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
	<pre class="comment">These imps are used in uvm_*_port, uvm_*_export and uvm_*_imp, using suffixes<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_TRANSPORT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_TRANSPORT_IMP"></a><b>			`UVM_BLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_BLOCKING_TRANSPORT_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_BLOCKING_TRANSPORT_IMP_SFX"></a><b>			`UVM_BLOCKING_TRANSPORT_IMP_SFX(SFX, imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_DEFAULT_TIMEOUT"></a>
					<span class="signature">

	<a name="macro_UVM_DEFAULT_TIMEOUT"></a><b>			`UVM_DEFAULT_TIMEOUT
</b> = 9200s

					</span>
	<pre class="comment">Macro: `UVM_DEFAULT_TIMEOUT

The default timeout for simulation, if not overridden by
<uvm_root::set_timeout> or <+UVM_TIMEOUT><br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_EXPORT_COMMON"></a>
					<span class="signature">

	<a name="macro_UVM_EXPORT_COMMON"></a><b>			`UVM_EXPORT_COMMON(MASK, TYPE_NAME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_FIX_REV"></a>
					<span class="signature">

	<a name="macro_UVM_FIX_REV"></a><b>			`UVM_FIX_REV
</b> = d

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_FIX_REV_d"></a>
					<span class="signature">

	<a name="macro_UVM_FIX_REV_d"></a><b>			`UVM_FIX_REV_d
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_FIX_VERSION_1_1_d"></a>
					<span class="signature">

	<a name="macro_UVM_FIX_VERSION_1_1_d"></a><b>			`UVM_FIX_VERSION_1_1_d
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_FUNCTION_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_FUNCTION_ERROR"></a><b>			`UVM_FUNCTION_ERROR
</b> = "TLM interface function not implemented"

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_GET_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_GET_IMP"></a><b>			`UVM_GET_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_GET_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_GET_PEEK_IMP"></a><b>			`UVM_GET_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_IMP_COMMON"></a>
					<span class="signature">

	<a name="macro_UVM_IMP_COMMON"></a><b>			`UVM_IMP_COMMON(MASK, TYPE_NAME, IMP)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MAJOR_REV"></a>
					<span class="signature">

	<a name="macro_UVM_MAJOR_REV"></a><b>			`UVM_MAJOR_REV
</b> = 1

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MAJOR_REV_1"></a>
					<span class="signature">

	<a name="macro_UVM_MAJOR_REV_1"></a><b>			`UVM_MAJOR_REV_1
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MAJOR_VERSION_1_1"></a>
					<span class="signature">

	<a name="macro_UVM_MAJOR_VERSION_1_1"></a><b>			`UVM_MAJOR_VERSION_1_1
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MINOR_REV"></a>
					<span class="signature">

	<a name="macro_UVM_MINOR_REV"></a><b>			`UVM_MINOR_REV
</b> = 1

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MINOR_REV_1"></a>
					<span class="signature">

	<a name="macro_UVM_MINOR_REV_1"></a><b>			`UVM_MINOR_REV_1
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_MS_IMP_COMMON"></a>
					<span class="signature">

	<a name="macro_UVM_MS_IMP_COMMON"></a><b>			`UVM_MS_IMP_COMMON(MASK, TYPE_NAME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NAME"></a>
					<span class="signature">

	<a name="macro_UVM_NAME"></a><b>			`UVM_NAME
</b> = UVM

					</span>
	<pre class="comment">Version numbers to be used in creating version strings for printing
or programmatic tesing against version numbers<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_GET_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_GET_IMP"></a><b>			`UVM_NONBLOCKING_GET_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_GET_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_GET_IMP_SFX"></a><b>			`UVM_NONBLOCKING_GET_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_GET_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_GET_PEEK_IMP"></a><b>			`UVM_NONBLOCKING_GET_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_PEEK_IMP"></a><b>			`UVM_NONBLOCKING_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_PEEK_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_PEEK_IMP_SFX"></a><b>			`UVM_NONBLOCKING_PEEK_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_PUT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_PUT_IMP"></a><b>			`UVM_NONBLOCKING_PUT_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_PUT_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_PUT_IMP_SFX"></a><b>			`UVM_NONBLOCKING_PUT_IMP_SFX(SFX, imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_TRANSPORT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_TRANSPORT_IMP"></a><b>			`UVM_NONBLOCKING_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_NONBLOCKING_TRANSPORT_IMP_SFX"></a>
					<span class="signature">

	<a name="macro_UVM_NONBLOCKING_TRANSPORT_IMP_SFX"></a><b>			`UVM_NONBLOCKING_TRANSPORT_IMP_SFX(SFX, imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_PEEK_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_PEEK_IMP"></a><b>			`UVM_PEEK_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_PH_TRACE"></a>
					<span class="signature">

	<a name="macro_UVM_PH_TRACE"></a><b>			`UVM_PH_TRACE(ID, MSG, PH, VERB)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_PORT_COMMON"></a>
					<span class="signature">

	<a name="macro_UVM_PORT_COMMON"></a><b>			`UVM_PORT_COMMON(MASK, TYPE_NAME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_PUT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_PUT_IMP"></a><b>			`UVM_PUT_IMP(imp, TYPE, arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_RESOURCE_GET_FCNS"></a>
					<span class="signature">

	<a name="macro_UVM_RESOURCE_GET_FCNS"></a><b>			`UVM_RESOURCE_GET_FCNS(base_type)
</b>

					</span>
	<pre class="comment">When specicializing resources the get_by_name and get_by_type
functions must be redefined.  The reason is that the version of these
functions in the base class (uvm_resource#(T)) returns an object of
type uvm_resource#(T).  In the specializations we must return an
object of the type of the specialization.  So, we call the base_class
implementation of these functions and then downcast to the subtype.

This macro is invokved once in each where a resource specialization
is a class defined as:

|  class <resource_specialization> extends uvm_resource#(T)

where <resource_specialization> is the name of the derived class.
The argument to this macro is T, the type of the uvm_resource#(T)
specialization.  The class in which the macro is defined must supply
a typedef of the specialized class of the form:

|  typedef <resource_specialization> this_subtype;

where <resource_specialization> is the same as above.  The macro
generates the get_by_name() and get_by_type() functions for the
specialized resource (i.e. resource subtype).<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_FUNCTION_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_FUNCTION_ERROR"></a><b>			`UVM_SEQ_ITEM_FUNCTION_ERROR
</b> = "Sequencer interface function not implemented"

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_GET_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_GET_MASK"></a><b>			`UVM_SEQ_ITEM_GET_MASK
</b> = (1<<7)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK"></a><b>			`UVM_SEQ_ITEM_GET_NEXT_ITEM_MASK
</b> = (1<<0)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK"></a><b>			`UVM_SEQ_ITEM_HAS_DO_AVAILABLE_MASK
</b> = (1<<3)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_ITEM_DONE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_ITEM_DONE_MASK"></a><b>			`UVM_SEQ_ITEM_ITEM_DONE_MASK
</b> = (1<<2)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PEEK_MASK"></a><b>			`UVM_SEQ_ITEM_PEEK_MASK
</b> = (1<<8)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PULL_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PULL_IMP"></a><b>			`UVM_SEQ_ITEM_PULL_IMP(imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
	<pre class="comment">----------------------------------------------------------------------
imp definitions
----------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PULL_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PULL_MASK"></a><b>			`UVM_SEQ_ITEM_PULL_MASK
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PUSH_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PUSH_MASK"></a><b>			`UVM_SEQ_ITEM_PUSH_MASK
</b> = (`UVM_SEQ_ITEM_PUT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PUT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PUT_MASK"></a><b>			`UVM_SEQ_ITEM_PUT_MASK
</b> = (1<<6)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_PUT_RESPONSE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_PUT_RESPONSE_MASK"></a><b>			`UVM_SEQ_ITEM_PUT_RESPONSE_MASK
</b> = (1<<5)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_TASK_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_TASK_ERROR"></a><b>			`UVM_SEQ_ITEM_TASK_ERROR
</b> = "Sequencer interface task not implemented"

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK"></a><b>			`UVM_SEQ_ITEM_TRY_NEXT_ITEM_MASK
</b> = (1<<1)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_UNI_PULL_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_UNI_PULL_MASK"></a><b>			`UVM_SEQ_ITEM_UNI_PULL_MASK
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK"></a><b>			`UVM_SEQ_ITEM_WAIT_FOR_SEQUENCES_MASK
</b> = (1<<4)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_SEQ_PORT"></a>
					<span class="signature">

	<a name="macro_UVM_SEQ_PORT"></a><b>			`UVM_SEQ_PORT(MASK, TYPE_NAME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TASK_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_TASK_ERROR"></a><b>			`UVM_TASK_ERROR
</b> = "TLM interface task not implemented"

					</span>
	<pre class="comment">-----------------------------------------------------------------------------
Copyright 2007-2011 Mentor Graphics Corporation
Copyright 2007-2010 Cadence Design Systems, Inc.
Copyright 2010 Synopsys, Inc.
All Rights Reserved Worldwide

Licensed under the Apache License, Version 2.0 (the
"License"); you may not use this file except in
compliance with the License.  You may obtain a copy of
the License at

<code><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></code>

Unless required by applicable law or agreed to in
writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied.  See
the License for the specific language governing
permissions and limitations under the License.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_ANALYSIS_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_ANALYSIS_MASK"></a><b>			`UVM_TLM_ANALYSIS_MASK
</b> = (1<<8)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_GET_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_GET_MASK"></a><b>			`UVM_TLM_BLOCKING_GET_MASK
</b> = (1<<1)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_GET_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_GET_PEEK_MASK"></a><b>			`UVM_TLM_BLOCKING_GET_PEEK_MASK
</b> = (`UVM_TLM_BLOCKING_GET_MASK    | `UVM_TLM_BLOCKING_PEEK_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_MASTER_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_MASTER_MASK"></a><b>			`UVM_TLM_BLOCKING_MASTER_MASK
</b> = (`UVM_TLM_BLOCKING_PUT_MASK       | `UVM_TLM_BLOCKING_GET_MASK | `UVM_TLM_BLOCKING_PEEK_MASK | `UVM_TLM_MASTER_BIT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_PEEK_MASK"></a><b>			`UVM_TLM_BLOCKING_PEEK_MASK
</b> = (1<<2)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_PUT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_PUT_MASK"></a><b>			`UVM_TLM_BLOCKING_PUT_MASK
</b> = (1<<0)

					</span>
	<pre class="comment">Primitive interfaces<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_SLAVE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_SLAVE_MASK"></a><b>			`UVM_TLM_BLOCKING_SLAVE_MASK
</b> = (`UVM_TLM_BLOCKING_PUT_MASK       | `UVM_TLM_BLOCKING_GET_MASK | `UVM_TLM_BLOCKING_PEEK_MASK | `UVM_TLM_SLAVE_BIT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_BLOCKING_TRANSPORT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_BLOCKING_TRANSPORT_MASK"></a><b>			`UVM_TLM_BLOCKING_TRANSPORT_MASK
</b> = (1<<3)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_B_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_B_MASK"></a><b>			`UVM_TLM_B_MASK
</b> = (1<<2)

					</span>
	<pre class="comment">MACRO: `UVM_TLM_B_MASK

Define blocking mask onehot assignment = 'b100<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_B_TRANSPORT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_B_TRANSPORT_IMP"></a><b>			`UVM_TLM_B_TRANSPORT_IMP(imp, T, t, delay)
</b>

					</span>
	<pre class="comment">Macro: `UVM_TLM_B_TRANSPORT_IMP

The macro wraps the function b_transport()
Execute a blocking transaction. Once this method returns,
the transaction is assumed to have been executed. Whether
that execution is succesful or not must be indicated by the
transaction itself.

The callee may modify or update the transaction object, subject
to any constraints imposed by the transaction class. The
initiator may re-use a transaction object from one call to
the next and across calls to b_transport().

The call to b_transport shall mark the first timing point of the
transaction. The return from b_transport() shall mark the final
timing point of the transaction. The timing annotation argument
allows the timing points to be offset from the simulation times
at which the task call and return are executed.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_FIFO_FUNCTION_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_FIFO_FUNCTION_ERROR"></a><b>			`UVM_TLM_FIFO_FUNCTION_ERROR
</b> = "fifo channel function not implemented"

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_FIFO_TASK_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_FIFO_TASK_ERROR"></a><b>			`UVM_TLM_FIFO_TASK_ERROR
</b> = "fifo channel task not implemented"

					</span>
	<pre class="comment">------------------------------------------------------------------------------
Copyright 2007-2011 Mentor Graphics Corporation
Copyright 2007-2011 Cadence Design Systems, Inc.
Copyright 2010 Synopsys, Inc.
All Rights Reserved Worldwide

Licensed under the Apache License, Version 2.0 (the
"License"); you may not use this file except in
compliance with the License.  You may obtain a copy of
the License at

<code><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></code>

Unless required by applicable law or agreed to in
writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied.  See
the License for the specific language governing
permissions and limitations under the License.
------------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_FUNCTION_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_FUNCTION_ERROR"></a><b>			`UVM_TLM_FUNCTION_ERROR
</b> = "TLM-2 interface function not implemented"

					</span>
	<pre class="comment">MACRO: `UVM_TLM_FUNCTION_ERROR

Defines Not-Yet-Implemented TLM functions<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_GET_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_GET_MASK"></a><b>			`UVM_TLM_GET_MASK
</b> = (`UVM_TLM_BLOCKING_GET_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_GET_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_GET_PEEK_MASK"></a><b>			`UVM_TLM_GET_PEEK_MASK
</b> = (`UVM_TLM_GET_MASK | `UVM_TLM_PEEK_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_GET_TYPE_NAME"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_GET_TYPE_NAME"></a><b>			`UVM_TLM_GET_TYPE_NAME(NAME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_MASTER_BIT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_MASTER_BIT_MASK"></a><b>			`UVM_TLM_MASTER_BIT_MASK
</b> = (1<<9)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_MASTER_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_MASTER_MASK"></a><b>			`UVM_TLM_MASTER_MASK
</b> = (`UVM_TLM_BLOCKING_MASTER_MASK    | `UVM_TLM_NONBLOCKING_MASTER_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NB_BW_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NB_BW_MASK"></a><b>			`UVM_TLM_NB_BW_MASK
</b> = (1<<1)

					</span>
	<pre class="comment">MACRO: `UVM_TLM_NB_BW_MASK

Define Non blocking backward mask onehot assignment = 'b010<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NB_FW_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NB_FW_MASK"></a><b>			`UVM_TLM_NB_FW_MASK
</b> = (1<<0)

					</span>
	<pre class="comment">MACRO: `UVM_TLM_NB_FW_MASK

Define Non blocking Forward mask onehot assignment = 'b001<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NB_TRANSPORT_BW_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NB_TRANSPORT_BW_IMP"></a><b>			`UVM_TLM_NB_TRANSPORT_BW_IMP(imp, T, P, t, p, delay)
</b>

					</span>
	<pre class="comment">Macro: `UVM_TLM_NB_TRANSPORT_BW_IMP


Implementation of the backward path.
The macro wraps the function called nb_transport_bw().
This function MUST be implemented in the INITIATOR component class.

Every call to this method may mark a timing point, including the final
timing point, in the execution of the transaction.
The timing annotation argument allows the timing point
to be offset from the simulation times at which the backward path is used.
The final timing point of a transaction may be marked by a call
to nb_transport_fw() within <`UVM_TLM_NB_TRANSPORT_FW_IMP> or a return from
this or subsequent call to nb_transport_bw().

See <TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset>
for more details on the semantics and rules of the nonblocking
transport interface.

Example:

| class master extends uvm_component;
|    uvm_tlm_nb_initiator_socket
|          #(trans, uvm_tlm_phase_e, this_t) initiator_socket;
|
|    function void build_phase(uvm_phase phase);
|       initiator_socket = new("initiator_socket", this, this);
|    endfunction
|
|    function uvm_tlm_sync_e nb_transport_bw(trans t,
|                                   ref uvm_tlm_phase_e p,
|                                   input uvm_tlm_time delay);
|        transaction = t;
|        state = p;
|        return UVM_TLM_ACCEPTED;
|    endfunction
|
|    ...
| endclass<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NB_TRANSPORT_FW_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NB_TRANSPORT_FW_IMP"></a><b>			`UVM_TLM_NB_TRANSPORT_FW_IMP(imp, T, P, t, p, delay)
</b>

					</span>
	<pre class="comment">Macro: `UVM_TLM_NB_TRANSPORT_FW_IMP

The macro wraps the forward path call function nb_transport_fw()

The first call to this method for a transaction marks the initial timing point.
Every call to this method may mark a timing point in the execution of the
transaction. The timing annotation argument allows the timing points
to be offset from the simulation times at which the forward path is used.
The final timing point of a transaction may be marked by a call
to nb_transport_bw() within <`UVM_TLM_NB_TRANSPORT_BW_IMP> or a return from this
or subsequent call to nb_transport_fw().

See <TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset>
for more details on the semantics and rules of the nonblocking
transport interface.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_GET_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_GET_MASK"></a><b>			`UVM_TLM_NONBLOCKING_GET_MASK
</b> = (1<<5)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_GET_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_GET_PEEK_MASK"></a><b>			`UVM_TLM_NONBLOCKING_GET_PEEK_MASK
</b> = (`UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_MASTER_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_MASTER_MASK"></a><b>			`UVM_TLM_NONBLOCKING_MASTER_MASK
</b> = (`UVM_TLM_NONBLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK | `UVM_TLM_MASTER_BIT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_PEEK_MASK"></a><b>			`UVM_TLM_NONBLOCKING_PEEK_MASK
</b> = (1<<6)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_PUT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_PUT_MASK"></a><b>			`UVM_TLM_NONBLOCKING_PUT_MASK
</b> = (1<<4)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_SLAVE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_SLAVE_MASK"></a><b>			`UVM_TLM_NONBLOCKING_SLAVE_MASK
</b> = (`UVM_TLM_NONBLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_GET_MASK | `UVM_TLM_NONBLOCKING_PEEK_MASK | `UVM_TLM_SLAVE_BIT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_NONBLOCKING_TRANSPORT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_NONBLOCKING_TRANSPORT_MASK"></a><b>			`UVM_TLM_NONBLOCKING_TRANSPORT_MASK
</b> = (1<<7)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_PEEK_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_PEEK_MASK"></a><b>			`UVM_TLM_PEEK_MASK
</b> = (`UVM_TLM_BLOCKING_PEEK_MASK   | `UVM_TLM_NONBLOCKING_PEEK_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_PUT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_PUT_MASK"></a><b>			`UVM_TLM_PUT_MASK
</b> = (`UVM_TLM_BLOCKING_PUT_MASK    | `UVM_TLM_NONBLOCKING_PUT_MASK)

					</span>
	<pre class="comment">Combination interfaces<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_SLAVE_BIT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_SLAVE_BIT_MASK"></a><b>			`UVM_TLM_SLAVE_BIT_MASK
</b> = (1<<10)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_SLAVE_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_SLAVE_MASK"></a><b>			`UVM_TLM_SLAVE_MASK
</b> = (`UVM_TLM_BLOCKING_SLAVE_MASK    | `UVM_TLM_NONBLOCKING_SLAVE_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_TASK_ERROR"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_TASK_ERROR"></a><b>			`UVM_TLM_TASK_ERROR
</b> = "TLM-2 interface task not implemented"

					</span>
	<pre class="comment">MACRO: `UVM_TLM_TASK_ERROR

Defines Not-Yet-Implemented TLM tasks<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TLM_TRANSPORT_MASK"></a>
					<span class="signature">

	<a name="macro_UVM_TLM_TRANSPORT_MASK"></a><b>			`UVM_TLM_TRANSPORT_MASK
</b> = (`UVM_TLM_BLOCKING_TRANSPORT_MASK | `UVM_TLM_NONBLOCKING_TRANSPORT_MASK)

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_TRANSPORT_IMP"></a>
					<span class="signature">

	<a name="macro_UVM_TRANSPORT_IMP"></a><b>			`UVM_TRANSPORT_IMP(imp, REQ, RSP, req_arg, rsp_arg)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_VERSION_1_1"></a>
					<span class="signature">

	<a name="macro_UVM_VERSION_1_1"></a><b>			`UVM_VERSION_1_1
</b>

					</span>
	<pre class="comment">Whole version identifiers that can be used in `ifdefs and `ifndefs
to do conditional compilation<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_UVM_VERSION_STRING"></a>
					<span class="signature">

	<a name="macro_UVM_VERSION_STRING"></a><b>			`UVM_VERSION_STRING
</b> = `"`UVM_NAME-`UVM_MAJOR_REV.`UVM_MINOR_REV`UVM_FIX_REV`"

					</span>
	<pre class="comment">When there is a FIX_REV, print as "M.mf"
When there is NO FIX_REV, print as "M.m".
Fix rev kind of string:<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_bottomup_phase"></a>
					<span class="signature">

	<a name="macro_m_uvm_bottomup_phase"></a><b>			`m_uvm_bottomup_phase(PHASE, COMP, PREFIX)
</b>

					</span>
	<pre class="comment">PREFIX``PHASE``_phase PREFIX``PHASE``_ph = PREFIX``PHASE``_phase::get();<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_component_registry_internal"></a>
					<span class="signature">

	<a name="macro_m_uvm_component_registry_internal"></a><b>			`m_uvm_component_registry_internal(T, S)
</b>

					</span>
	<pre class="comment">This is needed due to an issue in of passing down strings
created by args to lower level macros.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_component_registry_param"></a>
					<span class="signature">

	<a name="macro_m_uvm_component_registry_param"></a><b>			`m_uvm_component_registry_param(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_get_type_name_func"></a>
					<span class="signature">

	<a name="macro_m_uvm_get_type_name_func"></a><b>			`m_uvm_get_type_name_func(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_object_create_func"></a>
					<span class="signature">

	<a name="macro_m_uvm_object_create_func"></a><b>			`m_uvm_object_create_func(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_object_registry_internal"></a>
					<span class="signature">

	<a name="macro_m_uvm_object_registry_internal"></a><b>			`m_uvm_object_registry_internal(T, S)
</b>

					</span>
	<pre class="comment">This is needed due to an issue in of passing down strings
created by args to lower level macros.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_object_registry_param"></a>
					<span class="signature">

	<a name="macro_m_uvm_object_registry_param"></a><b>			`m_uvm_object_registry_param(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_int"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_int"></a><b>			`m_uvm_record_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">Purpose: provide print functionality for a specific integral field. This
macro is available for user access. If used externally, a record_options
object must be avaialble and must have the name opt.

Postcondition: ~ARG~ is printed using the format set by the FLAGS.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_object"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_object"></a><b>			`m_uvm_record_object(ARG, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_qda_enum"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_qda_enum"></a><b>			`m_uvm_record_qda_enum(ARG, FLAG, SZ)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_qda_int"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_qda_int"></a><b>			`m_uvm_record_qda_int(ARG, FLAG, SZ)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_qda_object"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_qda_object"></a><b>			`m_uvm_record_qda_object(ARG, FLAG, SZ)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_qda_string"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_qda_string"></a><b>			`m_uvm_record_qda_string(ARG, FLAG, SZ)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_record_string"></a>
					<span class="signature">

	<a name="macro_m_uvm_record_string"></a><b>			`m_uvm_record_string(ARG, STR, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_register_sequence"></a>
					<span class="signature">

	<a name="macro_m_uvm_register_sequence"></a><b>			<s>`m_uvm_register_sequence(TYPE_NAME, SEQUENCER)</s>
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------

DEPRECATED

Group- Sequence Registration Macros

The sequence-specific macros perform the same function as the set of
`uvm_object_*_utils macros, except they also set the default sequencer type
the sequence will run on.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_task_phase"></a>
					<span class="signature">

	<a name="macro_m_uvm_task_phase"></a><b>			`m_uvm_task_phase(PHASE, COMP, PREFIX)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_m_uvm_topdown_phase"></a>
					<span class="signature">

	<a name="macro_m_uvm_topdown_phase"></a><b>			`m_uvm_topdown_phase(PHASE, COMP, PREFIX)
</b>

					</span>
	<pre class="comment">PREFIX``PHASE``_phase PREFIX``PHASE``_ph = PREFIX``PHASE``_phase::get();<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_add_to_seq_lib"></a>
					<span class="signature">

	<a name="macro_uvm_add_to_seq_lib"></a><b>			`uvm_add_to_seq_lib(TYPE, LIBTYPE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_analysis_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_analysis_imp_decl"></a><b>			`uvm_analysis_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_analysis_imp_decl

| `uvm_analysis_imp_decl(SFX)

Define the class uvm_analysis_impSFX for providing an analysis
implementation. ~SFX~ is the suffix for the new class type. The analysis
implemenation is the write function. The `uvm_analysis_imp_decl allows
for a scoreboard (or other analysis component) to support input from many
places. For example:

| `uvm_analysis_imp_decl(_ingress)
| `uvm_analysis_imp_decl(_egress)
|
| class myscoreboard extends uvm_component;
|   uvm_analysis_imp_ingress#(mydata, myscoreboard) ingress;
|   uvm_analysis_imp_egress#(mydata, myscoreboard) egress;
|   mydata ingress_list[$];
|   ...
|
|   function new(string name, uvm_component parent);
|     super.new(name,parent);
|     ingress = new("ingress", this);
|     egress = new("egress", this);
|   endfunction
|
|   function void write_ingress(mydata t);
|     ingress_list.push_back(t);
|   endfunction
|
|   function void write_egress(mydata t);
|     find_match_in_ingress_list(t);
|   endfunction
|
|   function void find_match_in_ingress_list(mydata t);
|     //implement scoreboarding for this particular DUT
|     ...
|   endfunction
| endclass<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_get_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_get_imp_decl"></a><b>			`uvm_blocking_get_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_get_imp_decl

| `uvm_blocking_get_imp_decl(SFX)

Define the class uvm_blocking_get_impSFX for providing blocking get
implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_get_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_get_peek_imp_decl"></a><b>			`uvm_blocking_get_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_get_peek_imp_decl

| `uvm_blocking_get_peek_imp_decl(SFX)

Define the class uvm_blocking_get_peek_impSFX for providing the
blocking get_peek implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_master_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_master_imp_decl"></a><b>			`uvm_blocking_master_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_master_imp_decl

| `uvm_blocking_master_imp_decl(SFX)

Define the class uvm_blocking_master_impSFX for providing the
blocking master implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_peek_imp_decl"></a><b>			`uvm_blocking_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_peek_imp_decl

| `uvm_blocking_peek_imp_decl(SFX)

Define the class uvm_blocking_peek_impSFX for providing blocking peek
implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_put_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_put_imp_decl"></a><b>			`uvm_blocking_put_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_put_imp_decl

| `uvm_blocking_put_imp_decl(SFX)

Define the class uvm_blocking_put_impSFX for providing blocking put
implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_slave_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_slave_imp_decl"></a><b>			`uvm_blocking_slave_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_slave_imp_decl

| `uvm_blocking_slave_imp_decl(SFX)

Define the class uvm_blocking_slave_impSFX for providing the
blocking slave implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_blocking_transport_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_blocking_transport_imp_decl"></a><b>			`uvm_blocking_transport_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_blocking_transport_imp_decl

| `uvm_blocking_transport_imp_decl(SFX)

Define the class uvm_blocking_transport_impSFX for providing the
blocking transport implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_builtin_bottomup_phase"></a>
					<span class="signature">

	<a name="macro_uvm_builtin_bottomup_phase"></a><b>			`uvm_builtin_bottomup_phase(PHASE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_builtin_task_phase"></a>
					<span class="signature">

	<a name="macro_uvm_builtin_task_phase"></a><b>			`uvm_builtin_task_phase(PHASE)
</b>

					</span>
	<pre class="comment">PREFIX``PHASE``_phase PREFIX``PHASE``_ph = PREFIX``PHASE``_phase::get();<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_builtin_topdown_phase"></a>
					<span class="signature">

	<a name="macro_uvm_builtin_topdown_phase"></a><b>			`uvm_builtin_topdown_phase(PHASE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_cb_trace"></a>
					<span class="signature">

	<a name="macro_uvm_cb_trace"></a><b>			`uvm_cb_trace(OBJ, CB, OPER)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_cb_trace_noobj"></a>
					<span class="signature">

	<a name="macro_uvm_cb_trace_noobj"></a><b>			`uvm_cb_trace_noobj(CB, OPER)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_param_utils"></a>
					<span class="signature">

	<a name="macro_uvm_component_param_utils"></a><b>			`uvm_component_param_utils(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_param_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_component_param_utils_begin"></a><b>			`uvm_component_param_utils_begin(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_registry"></a>
					<span class="signature">

	<a name="macro_uvm_component_registry"></a><b>			`uvm_component_registry(T, S)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_component_registry

Registers a uvm_component-based class with the factory

| `uvm_component_registry(T,S)

Registers a uvm_component-based class ~T~ and lookup
string ~S~ with the factory. ~S~ typically is the
name of the class in quotes. The <`uvm_object_utils>
family of macros uses this macro.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_utils"></a>
					<span class="signature">

	<a name="macro_uvm_component_utils"></a><b>			`uvm_component_utils(T)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_component_end

uvm_component-based class declarations may contain one of the above forms of
utility macros.

For simple components with no field macros, use

|  `uvm_component_utils(TYPE)

For simple components with field macros, use

|  `uvm_component_utils_begin(TYPE)
|    `uvm_field_* macro invocations here
|  `uvm_component_utils_end

For parameterized components with no field macros, use

|  `uvm_component_param_utils(TYPE)

For parameterized components with field macros, use

|  `uvm_component_param_utils_begin(TYPE)
|    `uvm_field_* macro invocations here
|  `uvm_component_utils_end

Simple (non-parameterized) components must use the uvm_components_utils*
versions, which do the following:

o Implements get_type_name, which returns TYPE as a string.

o Implements create, which allocates a component of type TYPE using a two
argument constructor. TYPE's constructor must have a name and a parent
argument.

o Registers the TYPE with the factory, using the string TYPE as the factory
lookup string for the type.

o Implements the static get_type() method which returns a factory
proxy object for the type.

o Implements the virtual get_object_type() method which works just like the
static get_type() method, but operates on an already allocated object.

Parameterized classes must use the uvm_object_param_utils* versions. They
differ from `uvm_object_utils only in that they do not supply a type name
when registering the object with the factory. As such, name-based lookup with
the factory for parameterized classes is not possible.

The macros with _begin suffixes are the same as the non-suffixed versions
except that they also start a block in which `uvm_field_* macros can be
placed. The block must be terminated by `uvm_component_utils_end.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_component_utils_begin"></a><b>			`uvm_component_utils_begin(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_component_utils_end"></a>
					<span class="signature">

	<a name="macro_uvm_component_utils_end"></a><b>			`uvm_component_utils_end
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_create"></a>
					<span class="signature">

	<a name="macro_uvm_create"></a><b>			`uvm_create(SEQ_OR_ITEM)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_create

| `uvm_create(SEQ_OR_ITEM)

This action creates the item or sequence using the factory.  It intentionally
does zero processing.  After this action completes, the user can manually set
values, manipulate rand_mode and constraint_mode, etc.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_create_on"></a>
					<span class="signature">

	<a name="macro_uvm_create_on"></a><b>			`uvm_create_on(SEQ_OR_ITEM, SEQR)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_create_on

| `uvm_create_on(SEQ_OR_ITEM, SEQR)

This is the same as <`uvm_create> except that it also sets the parent sequence
to the sequence in which the macro is invoked, and it sets the sequencer to
the specified ~SEQR~ argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_create_seq"></a>
					<span class="signature">

	<a name="macro_uvm_create_seq"></a><b>			`uvm_create_seq(UVM_SEQ, SEQR_CONS_IF)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_declare_p_sequencer"></a>
					<span class="signature">

	<a name="macro_uvm_declare_p_sequencer"></a><b>			`uvm_declare_p_sequencer(SEQUENCER)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_declare_p_sequencer

This macro is used to declare a variable ~p_sequencer~ whose type is
specified by ~SEQUENCER~.

| `uvm_declare_p_sequencer(SEQUENCER)

The example below shows using the the `uvm_declare_p_sequencer macro
along with the uvm_object_utils macros to set up the sequence but
not register the sequence in the sequencer's library.

| class mysequence extends uvm_sequence#(mydata);
|   `uvm_object_utils(mysequence)
|   `uvm_declare_p_sequencer(some_seqr_type)
|   task body;
|     //Access some variable in the user's custom sequencer
|     if(p_sequencer.some_variable) begin
|       ...
|     end
|   endtask
| endclass<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_declare_sequence_lib"></a>
					<span class="signature">

	<a name="macro_uvm_declare_sequence_lib"></a><b>			<s>`uvm_declare_sequence_lib</s>
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------

DEPRECATED


Group- Sequencer Registration Macros

The sequencer-specific macros perform the same function as the set of
`uvm_componenent_*utils macros except that they also declare the plumbing
necessary for creating the sequencer's sequence library.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_delay"></a>
					<span class="signature">

	<a name="macro_uvm_delay"></a><b>			`uvm_delay(TIME)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do"></a>
					<span class="signature">

	<a name="macro_uvm_do"></a><b>			`uvm_do(SEQ_OR_ITEM)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do

| `uvm_do(SEQ_OR_ITEM)

This macro takes as an argument a uvm_sequence_item variable or object.
The argument is created using <`uvm_create> if necessary,
then randomized.
In the case of an item, it is randomized after the call to
<uvm_sequence_base::start_item()> returns.
This is called late-randomization.
In the case of a sequence, the sub-sequence is started using
<uvm_sequence_base::start()> with ~call_pre_post~ set to 0.
In the case of an item,
the item is sent to the driver through the associated sequencer.

For a sequence item, the following are called, in order

|
|   `uvm_create(item)
|   sequencer.wait_for_grant(prior) (task)
|   this.pre_do(1)                  (task)
|   item.randomize()
|   this.mid_do(item)               (func)
|   sequencer.send_request(item)    (func)
|   sequencer.wait_for_item_done()  (task)
|   this.post_do(item)              (func)
|

For a sequence, the following are called, in order

|
|   `uvm_create(sub_seq)
|   sub_seq.randomize()
|   sub_seq.pre_start()         (task)
|   this.pre_do(0)              (task)
|   this.mid_do(sub_seq)        (func)
|   sub_seq.body()              (task)
|   this.post_do(sub_seq)       (func)
|   sub_seq.post_start()        (task)
|<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_callbacks"></a>
					<span class="signature">

	<a name="macro_uvm_do_callbacks"></a><b>			`uvm_do_callbacks(T, CB, METHOD)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_callbacks_exit_on"></a>
					<span class="signature">

	<a name="macro_uvm_do_callbacks_exit_on"></a><b>			`uvm_do_callbacks_exit_on(T, CB, METHOD, VAL)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_obj_callbacks"></a>
					<span class="signature">

	<a name="macro_uvm_do_obj_callbacks"></a><b>			`uvm_do_obj_callbacks(T, CB, OBJ, METHOD)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------
MACRO: `uvm_do_obj_callbacks

| `uvm_do_obj_callbacks(T,CB,OBJ,METHOD)

Calls the given ~METHOD~ of all callbacks based on type ~CB~ registered with
the given object, ~OBJ~, which is or is based on type ~T~.

This macro is identical to <`uvm_do_callbacks> macro,
but it has an additional ~OBJ~ argument to allow the specification of an
external object to associate the callback with. For example, if the
callbacks are being applied in a sequence, ~OBJ~ could be specified
as the associated sequencer or parent sequence.

|    ...
|    `uvm_do_callbacks(mycb, mycomp, seqr, my_function(seqr, curr_addr, curr_data))
|    ...
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_obj_callbacks_exit_on"></a>
					<span class="signature">

	<a name="macro_uvm_do_obj_callbacks_exit_on"></a><b>			`uvm_do_obj_callbacks_exit_on(T, CB, OBJ, METHOD, VAL)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------
MACRO: `uvm_do_obj_callbacks_exit_on

| `uvm_do_obj_callbacks_exit_on(T,CB,OBJ,METHOD,VAL)

Calls the given ~METHOD~ of all callbacks of type ~CB~ registered with
the given object ~OBJ~, which must be or be based on type ~T~, and returns
upon the first callback that returns the bit value given by ~VAL~. It is
exactly the same as the <`uvm_do_callbacks_exit_on> but has a specific
object instance (instead of the implicit this instance) as the third
argument.

| ...
|  // Exit if a callback returns a 1
|  `uvm_do_callbacks_exit_on(mycomp, mycb, seqr, drop_trans(seqr,trans), 1)
| ...

Because this macro calls ~return~, its use is restricted to implementations
of functions that return a ~bit~ value, as in the above example.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_on"></a>
					<span class="signature">

	<a name="macro_uvm_do_on"></a><b>			`uvm_do_on(SEQ_OR_ITEM, SEQR)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_on

| `uvm_do_on(SEQ_OR_ITEM, SEQR)

This is the same as <`uvm_do> except that it also sets the parent sequence to
the sequence in which the macro is invoked, and it sets the sequencer to the
specified ~SEQR~ argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_on_pri"></a>
					<span class="signature">

	<a name="macro_uvm_do_on_pri"></a><b>			`uvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_on_pri

| `uvm_do_on_pri(SEQ_OR_ITEM, SEQR, PRIORITY)

This is the same as <`uvm_do_pri> except that it also sets the parent sequence
to the sequence in which the macro is invoked, and it sets the sequencer to
the specified ~SEQR~ argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_on_pri_with"></a>
					<span class="signature">

	<a name="macro_uvm_do_on_pri_with"></a><b>			`uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_on_pri_with

| `uvm_do_on_pri_with(SEQ_OR_ITEM, SEQR, PRIORITY, CONSTRAINTS)

This is the same as `uvm_do_pri_with except that it also sets the parent
sequence to the sequence in which the macro is invoked, and it sets the
sequencer to the specified ~SEQR~ argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_on_with"></a>
					<span class="signature">

	<a name="macro_uvm_do_on_with"></a><b>			`uvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_on_with

| `uvm_do_on_with(SEQ_OR_ITEM, SEQR, CONSTRAINTS)

This is the same as <`uvm_do_with> except that it also sets the parent
sequence to the sequence in which the macro is invoked, and it sets the
sequencer to the specified ~SEQR~ argument.
The user must supply brackets around the constraints.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_pri"></a>
					<span class="signature">

	<a name="macro_uvm_do_pri"></a><b>			`uvm_do_pri(SEQ_OR_ITEM, PRIORITY)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_pri

| `uvm_do_pri(SEQ_OR_ITEM, PRIORITY)

This is the same as `uvm_do except that the sequene item or sequence is
executed with the priority specified in the argument<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_pri_with"></a>
					<span class="signature">

	<a name="macro_uvm_do_pri_with"></a><b>			`uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_pri_with

| `uvm_do_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)

This is the same as `uvm_do_pri except that the given constraint block is
applied to the item or sequence in a randomize with statement before
execution.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_seq"></a>
					<span class="signature">

	<a name="macro_uvm_do_seq"></a><b>			`uvm_do_seq(UVM_SEQ, SEQR_CONS_IF)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_seq_with"></a>
					<span class="signature">

	<a name="macro_uvm_do_seq_with"></a><b>			`uvm_do_seq_with(UVM_SEQ, SEQR_CONS_IF, CONSTRAINTS)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_do_with"></a>
					<span class="signature">

	<a name="macro_uvm_do_with"></a><b>			`uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_do_with

| `uvm_do_with(SEQ_OR_ITEM, CONSTRAINTS)

This is the same as `uvm_do except that the constraint block in the 2nd
argument is applied to the item or sequence in a randomize with statement
before execution.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_end_package"></a>
					<span class="signature">

	<a name="macro_uvm_end_package"></a><b>			`uvm_end_package
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_error"></a>
					<span class="signature">

	<a name="macro_uvm_error"></a><b>			`uvm_error(ID, MSG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_error

| `uvm_error(ID,MSG)

Calls uvm_report_error with a verbosity of UVM_NONE. The message can not
be turned off using the reporter's verbosity setting, but can be turned off
by setting the action for the message.  ~ID~ is given as the message tag and
~MSG~ is given as the message text. The file and line are also sent to the
uvm_report_error call.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_error_context"></a>
					<span class="signature">

	<a name="macro_uvm_error_context"></a><b>			`uvm_error_context(ID, MSG, CNTXT)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_error_context

| `uvm_error_context(ID,MSG,CNTXT)

Operates identically to `uvm_error but requires that the
context, or <uvm_report_object> in which the message is printed be
explicitly supplied as a macro argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_fatal"></a>
					<span class="signature">

	<a name="macro_uvm_fatal"></a><b>			`uvm_fatal(ID, MSG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_fatal

| `uvm_fatal(ID,MSG)

Calls uvm_report_fatal with a verbosity of UVM_NONE. The message can not
be turned off using the reporter's verbosity setting, but can be turned off
by setting the action for the message.  ~ID~ is given as the message tag and
~MSG~ is given as the message text. The file and line are also sent to the
uvm_report_fatal call.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_fatal_context"></a>
					<span class="signature">

	<a name="macro_uvm_fatal_context"></a><b>			`uvm_fatal_context(ID, MSG, CNTXT)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_fatal_context

| `uvm_fatal_context(ID,MSG,CNTXT)

Operates identically to `uvm_fatal but requires that the
context, or <uvm_report_object>, in which the message is printed be
explicitly supplied as a macro argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_byte"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_byte"></a><b>			`uvm_field_aa_int_byte(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_byte

Implements the data operations for an associative array of integral
types indexed by the ~byte~ data type.

|  `uvm_field_aa_int_byte(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~byte~ key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_byte_unsigned"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_byte_unsigned"></a><b>			`uvm_field_aa_int_byte_unsigned(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_byte_unsigned

Implements the data operations for an associative array of integral
types indexed by the ~byte unsigned~ data type.

|  `uvm_field_aa_int_byte_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~byte unsigned~ key, and ~FLAG~ is a bitwise OR of one or more flag
settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_enumkey"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_enumkey"></a><b>			`uvm_field_aa_int_enumkey(KEY, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_enumkey

Implements the data operations for an associative array of integral
types indexed by any enumeration key data type.

|  `uvm_field_aa_int_longint_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~longint unsigned~ key, and ~FLAG~ is a bitwise OR of one or more
flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_int"></a><b>			`uvm_field_aa_int_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_int

Implements the data operations for an associative array of integral
types indexed by the ~int~ data type.

|  `uvm_field_aa_int_int(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~int~ key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_int_unsigned"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_int_unsigned"></a><b>			`uvm_field_aa_int_int_unsigned(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_int_unsigned

Implements the data operations for an associative array of integral
types indexed by the ~int unsigned~ data type.

|  `uvm_field_aa_int_int_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~int unsigned~ key, and ~FLAG~ is a bitwise OR of one or more flag
settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_integer"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_integer"></a><b>			`uvm_field_aa_int_integer(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_integer

Implements the data operations for an associative array of integral
types indexed by the ~integer~ data type.

|  `uvm_field_aa_int_integer(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~integer~ key, and ~FLAG~ is a bitwise OR of one or more flag settings
as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_integer_unsigned"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_integer_unsigned"></a><b>			`uvm_field_aa_int_integer_unsigned(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_integer_unsigned

Implements the data operations for an associative array of integral
types indexed by the ~integer unsigned~ data type.

|  `uvm_field_aa_int_integer_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~integer unsigned~ key, and ~FLAG~ is a bitwise OR of one or more
flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_key"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_key"></a><b>			`uvm_field_aa_int_key(KEY, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_key

Implements the data operations for an associative array of integral
types indexed by any integral key data type.

|  `uvm_field_aa_int_key(long unsigned,ARG,FLAG)

~KEY~ is the data type of the integral key, ~ARG~ is the name of a property
that is an associative array of integrals, and ~FLAG~ is a bitwise OR of one
or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_longint"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_longint"></a><b>			`uvm_field_aa_int_longint(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_longint

Implements the data operations for an associative array of integral
types indexed by the ~longint~ data type.

|  `uvm_field_aa_int_longint(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~longint~ key, and ~FLAG~ is a bitwise OR of one or more flag settings
as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_longint_unsigned"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_longint_unsigned"></a><b>			`uvm_field_aa_int_longint_unsigned(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_longint_unsigned

Implements the data operations for an associative array of integral
types indexed by the ~longint unsigned~ data type.

|  `uvm_field_aa_int_longint_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~longint unsigned~ key, and ~FLAG~ is a bitwise OR of one or more
flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_shortint"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_shortint"></a><b>			`uvm_field_aa_int_shortint(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_shortint

Implements the data operations for an associative array of integral
types indexed by the ~shortint~ data type.

|  `uvm_field_aa_int_shortint(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~shortint~ key, and ~FLAG~ is a bitwise OR of one or more flag
settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_shortint_unsigned"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_shortint_unsigned"></a><b>			`uvm_field_aa_int_shortint_unsigned(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_shortint_unsigned

Implements the data operations for an associative array of integral
types indexed by the ~shortint unsigned~ data type.

|  `uvm_field_aa_int_shortint_unsigned(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with ~shortint unsigned~ key, and ~FLAG~ is a bitwise OR of one or more
flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_int_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_int_string"></a><b>			`uvm_field_aa_int_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_int_string

Implements the data operations for an associative array of integrals indexed
by ~string~.

|  `uvm_field_aa_int_string(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of integrals
with string key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_object_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_object_int"></a><b>			`uvm_field_aa_object_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_object_int

Implements the data operations for an associative array of <uvm_object>-based
objects indexed by the ~int~ data type.

|  `uvm_field_aa_object_int(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of objects
with ~int~ key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_object_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_object_string"></a><b>			`uvm_field_aa_object_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_object_string

Implements the data operations for an associative array of <uvm_object>-based
objects indexed by ~string~.

|  `uvm_field_aa_object_string(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of objects
with string key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_aa_string_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_aa_string_string"></a><b>			`uvm_field_aa_string_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_aa_string_string

Implements the data operations for an associative array of strings indexed
by ~string~.

|  `uvm_field_aa_string_string(ARG,FLAG)

~ARG~ is the name of a property that is an associative array of strings
with string key, and ~FLAG~ is a bitwise OR of one or more flag settings as
described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_array_enum"></a>
					<span class="signature">

	<a name="macro_uvm_field_array_enum"></a><b>			`uvm_field_array_enum(T, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_array_enum

Implements the data operations for a one-dimensional dynamic array of
enums.

|  `uvm_field_array_enum(T,ARG,FLAG)

~T~ is a one-dimensional dynamic array of enums _type_,
~ARG~ is an instance of that type, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_array_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_array_int"></a><b>			`uvm_field_array_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_array_int

Implements the data operations for a one-dimensional dynamic array of
integrals.

|  `uvm_field_array_int(ARG,FLAG)

~ARG~ is a one-dimensional dynamic array of integrals,
and ~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_array_object"></a>
					<span class="signature">

	<a name="macro_uvm_field_array_object"></a><b>			`uvm_field_array_object(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_array_object

Implements the data operations for a one-dimensional dynamic array
of <uvm_object>-based objects.

|  `uvm_field_array_object(ARG,FLAG)

~ARG~ is a one-dimensional dynamic array of <uvm_object>-based objects,
and ~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_array_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_array_string"></a><b>			`uvm_field_array_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_array_string

Implements the data operations for a one-dimensional dynamic array
of strings.

|  `uvm_field_array_string(ARG,FLAG)

~ARG~ is a one-dimensional dynamic array of strings, and ~FLAG~ is a bitwise
OR of one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_enum"></a>
					<span class="signature">

	<a name="macro_uvm_field_enum"></a><b>			`uvm_field_enum(T, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_enum

Implements the data operations for an enumerated property.

|  `uvm_field_enum(T,ARG,FLAG)

~T~ is an enumerated _type_, ~ARG~ is an instance of that type, and
~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_event"></a>
					<span class="signature">

	<a name="macro_uvm_field_event"></a><b>			`uvm_field_event(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_event

Implements the data operations for an event property.

|  `uvm_field_event(ARG,FLAG)

~ARG~ is an event property of the class, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_int"></a><b>			`uvm_field_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_int

Implements the data operations for any packed integral property.

|  `uvm_field_int(ARG,FLAG)

~ARG~ is an integral property of the class, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_object"></a>
					<span class="signature">

	<a name="macro_uvm_field_object"></a><b>			`uvm_field_object(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_object

Implements the data operations for an <uvm_object>-based property.

|  `uvm_field_object(ARG,FLAG)

~ARG~ is an object property of the class, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_queue_enum"></a>
					<span class="signature">

	<a name="macro_uvm_field_queue_enum"></a><b>			`uvm_field_queue_enum(T, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_queue_enum

Implements the data operations for a one-dimensional queue of enums.

|  `uvm_field_queue_enum(T,ARG,FLAG)

~T~ is a queue of enums _type_, ~ARG~ is an instance of that type,
and ~FLAG~ is a bitwise OR of one or more flag settings as described
in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_queue_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_queue_int"></a><b>			`uvm_field_queue_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_queue_int

Implements the data operations for a queue of integrals.

|  `uvm_field_queue_int(ARG,FLAG)

~ARG~ is a one-dimensional queue of integrals,
and ~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_queue_object"></a>
					<span class="signature">

	<a name="macro_uvm_field_queue_object"></a><b>			`uvm_field_queue_object(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_queue_object

Implements the data operations for a queue of <uvm_object>-based objects.

|  `uvm_field_queue_object(ARG,FLAG)

~ARG~ is a one-dimensional queue of <uvm_object>-based objects,
and ~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_queue_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_queue_string"></a><b>			`uvm_field_queue_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_queue_string

Implements the data operations for a queue of strings.

|  `uvm_field_queue_string(ARG,FLAG)

~ARG~ is a one-dimensional queue of strings, and ~FLAG~ is a bitwise
OR of one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_real"></a>
					<span class="signature">

	<a name="macro_uvm_field_real"></a><b>			`uvm_field_real(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_real

Implements the data operations for any real property.

|  `uvm_field_real(ARG,FLAG)

~ARG~ is an real property of the class, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_sarray_enum"></a>
					<span class="signature">

	<a name="macro_uvm_field_sarray_enum"></a><b>			`uvm_field_sarray_enum(T, ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_sarray_enum

Implements the data operations for a one-dimensional static array of
enums.

|  `uvm_field_sarray_enum(T,ARG,FLAG)

~T~ is a one-dimensional dynamic array of enums _type_, ~ARG~ is an
instance of that type, and ~FLAG~ is a bitwise OR of one or more flag
settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_sarray_int"></a>
					<span class="signature">

	<a name="macro_uvm_field_sarray_int"></a><b>			`uvm_field_sarray_int(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_sarray_int

Implements the data operations for a one-dimensional static array of
integrals.

|  `uvm_field_sarray_int(ARG,FLAG)

~ARG~ is a one-dimensional static array of integrals, and ~FLAG~
is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_sarray_object"></a>
					<span class="signature">

	<a name="macro_uvm_field_sarray_object"></a><b>			`uvm_field_sarray_object(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_sarray_object

Implements the data operations for a one-dimensional static array of
<uvm_object>-based objects.

|  `uvm_field_sarray_object(ARG,FLAG)

~ARG~ is a one-dimensional static array of <uvm_object>-based objects,
and ~FLAG~ is a bitwise OR of one or more flag settings as described in
<Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_sarray_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_sarray_string"></a><b>			`uvm_field_sarray_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_sarray_string

Implements the data operations for a one-dimensional static array of
strings.

|  `uvm_field_sarray_string(ARG,FLAG)

~ARG~ is a one-dimensional static array of strings, and ~FLAG~ is a bitwise
OR of one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_string"></a>
					<span class="signature">

	<a name="macro_uvm_field_string"></a><b>			`uvm_field_string(ARG, FLAG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_string

Implements the data operations for a string property.

|  `uvm_field_string(ARG,FLAG)

~ARG~ is a string property of the class, and ~FLAG~ is a bitwise OR of
one or more flag settings as described in <Field Macros> above.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_field_utils_begin"></a><b>			`uvm_field_utils_begin(T)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_field_utils_end

These macros form a block in which `uvm_field_* macros can be placed.
Used as

|  `uvm_field_utils_begin(TYPE)
|    `uvm_field_* macros here
|  `uvm_field_utils_end


These macros do ~not~ perform factory registration nor implement the
~get_type_name~ and ~create~ methods. Use this form when you need custom
implementations of these two methods, or when you are setting up field macros
for an abstract class (i.e. virtual class).<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_field_utils_end"></a>
					<span class="signature">

	<a name="macro_uvm_field_utils_end"></a><b>			`uvm_field_utils_end
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_file"></a>
					<span class="signature">

	<a name="macro_uvm_file"></a><b>			`uvm_file
</b> = `__FILE__

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_get_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_get_imp_decl"></a><b>			`uvm_get_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_get_imp_decl

| `uvm_get_imp_decl(SFX)

Define the class uvm_get_impSFX for providing both blocking and
non-blocking get implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_get_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_get_peek_imp_decl"></a><b>			`uvm_get_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_get_peek_imp_decl

| `uvm_get_peek_imp_decl(SFX)

Define the class uvm_get_peek_impSFX for providing both blocking and
non-blocking get_peek implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_info"></a>
					<span class="signature">

	<a name="macro_uvm_info"></a><b>			`uvm_info(ID, MSG, VERBOSITY)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_info

| `uvm_info(ID,MSG,VERBOSITY)

Calls uvm_report_info if ~VERBOSITY~ is lower than the configured verbosity of
the associated reporter. ~ID~ is given as the message tag and ~MSG~ is given as
the message text. The file and line are also sent to the uvm_report_info call.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_info_context"></a>
					<span class="signature">

	<a name="macro_uvm_info_context"></a><b>			`uvm_info_context(ID, MSG, VERBOSITY, CNTXT)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_info_context

| `uvm_info_context(ID,MSG,VERBOSITY,CNTXT)

Operates identically to `uvm_info but requires that the
context, or <uvm_report_object>, in which the message is printed be
explicitly supplied as a macro argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_line"></a>
					<span class="signature">

	<a name="macro_uvm_line"></a><b>			`uvm_line
</b> = `__LINE__

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_master_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_master_imp_decl"></a><b>			`uvm_master_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_master_imp_decl

| `uvm_master_imp_decl(SFX)

Define the class uvm_master_impSFX for providing both blocking and
non-blocking master implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_new_func"></a>
					<span class="signature">

	<a name="macro_uvm_new_func"></a><b>			`uvm_new_func
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_non_blocking_transport_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_non_blocking_transport_imp_decl"></a><b>			`uvm_non_blocking_transport_imp_decl(SFX)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_get_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_get_imp_decl"></a><b>			`uvm_nonblocking_get_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_get_imp_decl

| `uvm_nonblocking_get_imp_decl(SFX)

Define the class uvm_nonblocking_get_impSFX for providing non-blocking
get implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_get_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_get_peek_imp_decl"></a><b>			`uvm_nonblocking_get_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_get_peek_imp_decl

| `uvm_nonblocking_get_peek_imp_decl(SFX)

Define the class uvm_nonblocking_get_peek_impSFX for providing non-blocking
get_peek implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_master_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_master_imp_decl"></a><b>			`uvm_nonblocking_master_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_master_imp_decl

| `uvm_nonblocking_master_imp_decl(SFX)

Define the class uvm_nonblocking_master_impSFX for providing the
non-blocking master implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_peek_imp_decl"></a><b>			`uvm_nonblocking_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_peek_imp_decl

| `uvm_nonblocking_peek_imp_decl(SFX)

Define the class uvm_nonblocking_peek_impSFX for providing non-blocking
peek implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_put_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_put_imp_decl"></a><b>			`uvm_nonblocking_put_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_put_imp_decl

| `uvm_nonblocking_put_imp_decl(SFX)

Define the class uvm_nonblocking_put_impSFX for providing non-blocking
put implementations.  ~SFX~ is the suffix for the new class type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_slave_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_slave_imp_decl"></a><b>			`uvm_nonblocking_slave_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_slave_imp_decl

| `uvm_nonblocking_slave_imp_decl(SFX)

Define the class uvm_nonblocking_slave_impSFX for providing the
non-blocking slave implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_nonblocking_transport_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_nonblocking_transport_imp_decl"></a><b>			`uvm_nonblocking_transport_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_nonblocking_transport_imp_decl

| `uvm_nonblocking_transport_imp_decl(SFX)

Define the class uvm_nonblocking_transport_impSFX for providing the
non-blocking transport implemenation.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_param_utils"></a>
					<span class="signature">

	<a name="macro_uvm_object_param_utils"></a><b>			`uvm_object_param_utils(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_param_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_object_param_utils_begin"></a><b>			`uvm_object_param_utils_begin(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_registry"></a>
					<span class="signature">

	<a name="macro_uvm_object_registry"></a><b>			`uvm_object_registry(T, S)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_object_registry

Register a uvm_object-based class with the factory

| `uvm_object_registry(T,S)

Registers a uvm_object-based class ~T~ and lookup
string ~S~ with the factory. ~S~ typically is the
name of the class in quotes. The <`uvm_object_utils>
family of macros uses this macro.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_utils"></a>
					<span class="signature">

	<a name="macro_uvm_object_utils"></a><b>			`uvm_object_utils(T)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_object_utils_end

<uvm_object>-based class declarations may contain one of the above forms of
utility macros.

For simple objects with no field macros, use

|  `uvm_object_utils(TYPE)

For simple objects with field macros, use

|  `uvm_object_utils_begin(TYPE)
|    `uvm_field_* macro invocations here
|  `uvm_object_utils_end

For parameterized objects with no field macros, use

|  `uvm_object_param_utils(TYPE)

For parameterized objects, with field macros, use

|  `uvm_object_param_utils_begin(TYPE)
|    `uvm_field_* macro invocations here
|  `uvm_object_utils_end

Simple (non-parameterized) objects use the uvm_object_utils* versions, which
do the following:

o Implements get_type_name, which returns TYPE as a string

o Implements create, which allocates an object of type TYPE by calling its
constructor with no arguments. TYPE's constructor, if defined, must have
default values on all it arguments.

o Registers the TYPE with the factory, using the string TYPE as the factory
lookup string for the type.

o Implements the static get_type() method which returns a factory
proxy object for the type.

o Implements the virtual get_object_type() method which works just like the
static get_type() method, but operates on an already allocated object.

Parameterized classes must use the uvm_object_param_utils* versions. They
differ from <`uvm_object_utils> only in that they do not supply a type name
when registering the object with the factory. As such, name-based lookup with
the factory for parameterized classes is not possible.

The macros with _begin suffixes are the same as the non-suffixed versions
except that they also start a block in which `uvm_field_* macros can be
placed. The block must be terminated by `uvm_object_utils_end.

Objects deriving from uvm_sequence must use the `uvm_sequence_* macros
instead of these macros.  See <`uvm_sequence_utils> for details.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_object_utils_begin"></a><b>			`uvm_object_utils_begin(T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_object_utils_end"></a>
					<span class="signature">

	<a name="macro_uvm_object_utils_end"></a><b>			`uvm_object_utils_end
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_array"></a>
					<span class="signature">

	<a name="macro_uvm_pack_array"></a><b>			`uvm_pack_array(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_array

Pack a dynamic array without having to also specify the bit size
of its elements. Array size must be non-zero.

| `uvm_pack_array(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_arrayN"></a>
					<span class="signature">

	<a name="macro_uvm_pack_arrayN"></a><b>			`uvm_pack_arrayN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_arrayN

Pack a dynamic array of integrals.

| `uvm_pack_arrayN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_enum"></a>
					<span class="signature">

	<a name="macro_uvm_pack_enum"></a><b>			`uvm_pack_enum(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_enum

Pack an enumeration value. Packing does not require its type be specified.

| `uvm_pack_enum(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_enumN"></a>
					<span class="signature">

	<a name="macro_uvm_pack_enumN"></a><b>			`uvm_pack_enumN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_enumN

Pack an integral variable.

| `uvm_pack_enumN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_int"></a>
					<span class="signature">

	<a name="macro_uvm_pack_int"></a><b>			`uvm_pack_int(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_int

Pack an integral variable without having to also specify the bit size.

| `uvm_pack_int(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_intN"></a>
					<span class="signature">

	<a name="macro_uvm_pack_intN"></a><b>			`uvm_pack_intN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_intN

Pack an integral variable.

| `uvm_pack_intN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_queue"></a>
					<span class="signature">

	<a name="macro_uvm_pack_queue"></a><b>			`uvm_pack_queue(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_queue

Pack a queue without having to also specify the bit size
of its elements. Queue must not be empty.

| `uvm_pack_queue(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_queueN"></a>
					<span class="signature">

	<a name="macro_uvm_pack_queueN"></a><b>			`uvm_pack_queueN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_queueN

Pack a queue of integrals.

| `uvm_pack_queueN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_real"></a>
					<span class="signature">

	<a name="macro_uvm_pack_real"></a><b>			`uvm_pack_real(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_real

Pack a variable of type real.

| `uvm_pack_real(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_sarray"></a>
					<span class="signature">

	<a name="macro_uvm_pack_sarray"></a><b>			`uvm_pack_sarray(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_sarray

Pack a static array without having to also specify the bit size
of its elements.

| `uvm_pack_sarray(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_sarrayN"></a>
					<span class="signature">

	<a name="macro_uvm_pack_sarrayN"></a><b>			`uvm_pack_sarrayN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_sarrayN

Pack a static array of integrals.

| `uvm_pack_sarray(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_pack_string"></a>
					<span class="signature">

	<a name="macro_uvm_pack_string"></a><b>			`uvm_pack_string(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_pack_string

Pack a string variable.

| `uvm_pack_string(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_package"></a>
					<span class="signature">

	<a name="macro_uvm_package"></a><b>			`uvm_package(PKG)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------

MACRO- `uvm_package

Use `uvm_package to define the SV package and to create a bogus type to help
automate triggering the static initializers of the package.
Use uvm_end_package to endpackage.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_peek_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_peek_imp_decl"></a><b>			`uvm_peek_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_peek_imp_decl

| `uvm_peek_imp_decl(SFX)

Define the class uvm_peek_impSFX for providing both blocking and
non-blocking peek implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_int_key4"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_int_key4"></a><b>			`uvm_print_aa_int_key4(KEY, F, R, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_int_object"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_int_object"></a><b>			`uvm_print_aa_int_object(F, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_int_object3"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_int_object3"></a><b>			`uvm_print_aa_int_object3(F, P, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_int"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_int"></a><b>			`uvm_print_aa_string_int(F)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------

Associative array printing methods

-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_int3"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_int3"></a><b>			`uvm_print_aa_string_int3(F, R, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_object"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_object"></a><b>			`uvm_print_aa_string_object(F, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_object3"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_object3"></a><b>			`uvm_print_aa_string_object3(F, P, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_string"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_string"></a><b>			`uvm_print_aa_string_string(F)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_aa_string_string2"></a>
					<span class="signature">

	<a name="macro_uvm_print_aa_string_string2"></a><b>			`uvm_print_aa_string_string2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_int"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_int"></a><b>			`uvm_print_array_int(F, R)
</b>

					</span>
	<pre class="comment">Uvm_print_array*
----------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_int3"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_int3"></a><b>			`uvm_print_array_int3(F, R, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_object"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_object"></a><b>			`uvm_print_array_object(F, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_object3"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_object3"></a><b>			`uvm_print_array_object3(F, P, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_string"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_string"></a><b>			`uvm_print_array_string(F)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_array_string2"></a>
					<span class="signature">

	<a name="macro_uvm_print_array_string2"></a><b>			`uvm_print_array_string2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_enum"></a>
					<span class="signature">

	<a name="macro_uvm_print_enum"></a><b>			`uvm_print_enum(T, F, NM, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_int"></a>
					<span class="signature">

	<a name="macro_uvm_print_int"></a><b>			`uvm_print_int(F, R)
</b>

					</span>
	<pre class="comment">uvm_print_int*
--------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_int3"></a>
					<span class="signature">

	<a name="macro_uvm_print_int3"></a><b>			`uvm_print_int3(F, R, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_int4"></a>
					<span class="signature">

	<a name="macro_uvm_print_int4"></a><b>			`uvm_print_int4(F, R, NM, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_object"></a>
					<span class="signature">

	<a name="macro_uvm_print_object"></a><b>			`uvm_print_object(F)
</b>

					</span>
	<pre class="comment">uvm_print_object*
-----------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_object2"></a>
					<span class="signature">

	<a name="macro_uvm_print_object2"></a><b>			`uvm_print_object2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_object_qda4"></a>
					<span class="signature">

	<a name="macro_uvm_print_object_qda4"></a><b>			`uvm_print_object_qda4(F, P, T, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_object_queue"></a>
					<span class="signature">

	<a name="macro_uvm_print_object_queue"></a><b>			`uvm_print_object_queue(F, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_object_queue3"></a>
					<span class="signature">

	<a name="macro_uvm_print_object_queue3"></a><b>			`uvm_print_object_queue3(F, P, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_qda_enum"></a>
					<span class="signature">

	<a name="macro_uvm_print_qda_enum"></a><b>			`uvm_print_qda_enum(F, P, T, ET)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_qda_int4"></a>
					<span class="signature">

	<a name="macro_uvm_print_qda_int4"></a><b>			`uvm_print_qda_int4(F, R, P, T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_queue_int"></a>
					<span class="signature">

	<a name="macro_uvm_print_queue_int"></a><b>			`uvm_print_queue_int(F, R)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_queue_int3"></a>
					<span class="signature">

	<a name="macro_uvm_print_queue_int3"></a><b>			`uvm_print_queue_int3(F, R, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_sarray_int3"></a>
					<span class="signature">

	<a name="macro_uvm_print_sarray_int3"></a><b>			`uvm_print_sarray_int3(F, R, P)
</b>

					</span>
	<pre class="comment">Uvm_print_sarray*
-----------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_sarray_object"></a>
					<span class="signature">

	<a name="macro_uvm_print_sarray_object"></a><b>			`uvm_print_sarray_object(F, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_sarray_object3"></a>
					<span class="signature">

	<a name="macro_uvm_print_sarray_object3"></a><b>			`uvm_print_sarray_object3(F, P, FLAG)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_sarray_string2"></a>
					<span class="signature">

	<a name="macro_uvm_print_sarray_string2"></a><b>			`uvm_print_sarray_string2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_string"></a>
					<span class="signature">

	<a name="macro_uvm_print_string"></a><b>			`uvm_print_string(F)
</b>

					</span>
	<pre class="comment">uvm_print_string*
-----------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_string2"></a>
					<span class="signature">

	<a name="macro_uvm_print_string2"></a><b>			`uvm_print_string2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_string_qda3"></a>
					<span class="signature">

	<a name="macro_uvm_print_string_qda3"></a><b>			`uvm_print_string_qda3(F, P, T)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_string_queue"></a>
					<span class="signature">

	<a name="macro_uvm_print_string_queue"></a><b>			`uvm_print_string_queue(F)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_print_string_queue2"></a>
					<span class="signature">

	<a name="macro_uvm_print_string_queue2"></a><b>			`uvm_print_string_queue2(F, P)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_put_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_put_imp_decl"></a><b>			`uvm_put_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_put_imp_decl

| `uvm_put_imp_decl(SFX)

Define the class uvm_put_impSFX for providing both blocking and
non-blocking put implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_rand_send"></a>
					<span class="signature">

	<a name="macro_uvm_rand_send"></a><b>			`uvm_rand_send(SEQ_OR_ITEM)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_rand_send

| `uvm_rand_send(SEQ_OR_ITEM)

This macro processes the item or sequence that has been already been
allocated (possibly with `uvm_create). The processing is done with
randomization.  Essentially, an `uvm_do without the create.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_rand_send_pri"></a>
					<span class="signature">

	<a name="macro_uvm_rand_send_pri"></a><b>			`uvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_rand_send_pri

| `uvm_rand_send_pri(SEQ_OR_ITEM, PRIORITY)

This is the same as `uvm_rand_send except that the sequene item or sequence
is executed with the priority specified in the argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_rand_send_pri_with"></a>
					<span class="signature">

	<a name="macro_uvm_rand_send_pri_with"></a><b>			`uvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_rand_send_pri_with

| `uvm_rand_send_pri_with(SEQ_OR_ITEM, PRIORITY, CONSTRAINTS)

This is the same as `uvm_rand_send_pri except that the given constraint block
is applied to the item or sequence in a randomize with statement before
execution.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_rand_send_with"></a>
					<span class="signature">

	<a name="macro_uvm_rand_send_with"></a><b>			`uvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_rand_send_with

| `uvm_rand_send_with(SEQ_OR_ITEM, CONSTRAINTS)

This is the same as `uvm_rand_send except that the given constraint block is
applied to the item or sequence in a randomize with statement before
execution.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_record_field"></a>
					<span class="signature">

	<a name="macro_uvm_record_field"></a><b>			`uvm_record_field(NAME, VALUE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_record_field

Macro for recording name-value pairs into a transaction recording database.
Requires a valid transaction handle, as provided by the
<uvm_transaction::begin_tr> and <uvm_component::begin_tr> methods.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_record_int"></a>
					<span class="signature">

	<a name="macro_uvm_record_int"></a><b>			`uvm_record_int(NAME, VALUE, SIZE, RADIX)
</b>

					</span>
	<pre class="comment">Use the following if the simulator's recording API can not
distinguish types.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_record_real"></a>
					<span class="signature">

	<a name="macro_uvm_record_real"></a><b>			`uvm_record_real(NAME, VALUE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_record_string"></a>
					<span class="signature">

	<a name="macro_uvm_record_string"></a><b>			`uvm_record_string(NAME, VALUE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_record_time"></a>
					<span class="signature">

	<a name="macro_uvm_record_time"></a><b>			`uvm_record_time(NAME, VALUE)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_register_cb"></a>
					<span class="signature">

	<a name="macro_uvm_register_cb"></a><b>			`uvm_register_cb(T, CB)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------
MACRO: `uvm_register_cb

| `uvm_register_cb(T,CB)

Registers the given ~CB~ callback type with the given ~T~ object type. If
a type-callback pair is not registered then a warning is issued if an
attempt is made to use the pair (add, delete, etc.).

The registration will typically occur in the component that executes the
given type of callback. For instance:

| virtual class mycb extends uvm_callback;
|   virtual function void doit();
| endclass
|
| class my_comp extends uvm_component;
|   `uvm_register_cb(my_comp,mycb)
|   ...
|   task run_phase(uvm_phase phase);
|     ...
|     `uvm_do_callbacks(my_comp, mycb, doit())
|   endtask
| endclass
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_send"></a>
					<span class="signature">

	<a name="macro_uvm_send"></a><b>			`uvm_send(SEQ_OR_ITEM)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_send

| `uvm_send(SEQ_OR_ITEM)

This macro processes the item or sequence that has been created using
`uvm_create.  The processing is done without randomization.  Essentially, an
`uvm_do without the create or randomization.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_send_pri"></a>
					<span class="signature">

	<a name="macro_uvm_send_pri"></a><b>			`uvm_send_pri(SEQ_OR_ITEM, PRIORITY)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_send_pri

| `uvm_send_pri(SEQ_OR_ITEM, PRIORITY)

This is the same as `uvm_send except that the sequene item or sequence is
executed with the priority specified in the argument.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequence_library_package"></a>
					<span class="signature">

	<a name="macro_uvm_sequence_library_package"></a><b>			`uvm_sequence_library_package(PKG_NAME)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------

MACRO- `uvm_sequence_library_package

This macro is used to trigger static initializers in packages. `uvm_package
creates a bogus type which gets referred to by uvm_sequence_library_package
to make a package-based variable of the bogus type.
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequence_library_utils"></a>
					<span class="signature">

	<a name="macro_uvm_sequence_library_utils"></a><b>			`uvm_sequence_library_utils(TYPE)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequence_library_utils

| `uvm_sequence_library_utils(TYPE)

Declares the infrastructure needed to define extensions to the
<uvm_sequence_library> class. You define new sequence library subtypes
to statically specify sequence membership from within sequence
definitions. See also <`uvm_add_to_sequence_library> for more information.


| typedef simple_seq_lib uvm_sequence_library #(simple_item);
|
| class simple_seq_lib_RST extends simple_seq_lib;
|
|   `uvm_object_utils(simple_seq_lib_RST)
|
|   `uvm_sequence_library_utils(simple_seq_lib_RST)
|
|   function new(string name="");
|     super.new(name);
|   endfunction
|
| endclass

Each library, itself a sequence, can then be started independently
on different sequencers or in different phases of the same sequencer.
See <uvm_sequencer_base::start_phase_sequence> for information on
starting default sequences.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequence_utils"></a>
					<span class="signature">

	<a name="macro_uvm_sequence_utils"></a><b>			`uvm_sequence_utils(TYPE_NAME, SEQUENCER)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequence_utils

The sequence macros can be used in non-parameterized <uvm_sequence #(REQ,RSP)>
extensions to pre-register the sequence with a given <uvm_sequencer #(REQ,RSP)>
type.

For sequences that do not use any `uvm_field macros:

|  `uvm_sequence_utils(TYPE_NAME,SQR_TYPE_NAME)

For sequences employing with field macros:

|  `uvm_sequence_utils_begin(TYPE_NAME,SQR_TYPE_NAME)
|    `uvm_field_* macro invocations here
|  `uvm_sequence_utils_end

The sequence-specific macros perform the same function as the set of
`uvm_object_*_utils macros except that they also register the sequence's
type, TYPE_NAME, with the given sequencer type, SQR_TYPE_NAME, and define
the p_sequencer variable and m_set_p_sequencer method.

Use `uvm_sequence_utils[_begin] for non-parameterized classes and
`uvm_sequence_param_utils[_begin] for parameterized classes.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequence_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_sequence_utils_begin"></a><b>			`uvm_sequence_utils_begin(TYPE_NAME, SEQUENCER)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequence_utils_begin<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequence_utils_end"></a>
					<span class="signature">

	<a name="macro_uvm_sequence_utils_end"></a><b>			`uvm_sequence_utils_end
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequence_utils_end<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequencer_param_utils"></a>
					<span class="signature">

	<a name="macro_uvm_sequencer_param_utils"></a><b>			`uvm_sequencer_param_utils(TYPE_NAME)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequencer_param_utils<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequencer_param_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_sequencer_param_utils_begin"></a><b>			`uvm_sequencer_param_utils_begin(TYPE_NAME)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequencer_param_utils_begin<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequencer_utils"></a>
					<span class="signature">

	<a name="macro_uvm_sequencer_utils"></a><b>			`uvm_sequencer_utils(TYPE_NAME)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequencer_utils<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequencer_utils_begin"></a>
					<span class="signature">

	<a name="macro_uvm_sequencer_utils_begin"></a><b>			`uvm_sequencer_utils_begin(TYPE_NAME)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequencer_utils_begin<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_sequencer_utils_end"></a>
					<span class="signature">

	<a name="macro_uvm_sequencer_utils_end"></a><b>			`uvm_sequencer_utils_end
</b>

					</span>
	<pre class="comment">MACRO- `uvm_sequencer_utils_end

The sequencer macros are used in uvm_sequencer-based class declarations
in one of four ways.

For simple sequencers, no field macros

`uvm_sequencer_utils(SQR_TYPE_NAME)

For simple sequencers, with field macros

`uvm_sequencer_utils_begin(SQR_TYPE_NAME)
`uvm_field_* macros here
`uvm_sequencer_utils_end

For parameterized sequencers, no field macros

`uvm_sequencer_param_utils(SQR_TYPE_NAME)

For parameterized sequencers, with field macros

`uvm_sequencer_param_utils_begin(SQR_TYPE_NAME)
`uvm_field_* macros here
`uvm_sequencer_utils_end

The sequencer-specific macros perform the same function as the set of
`uvm_componenent_*utils macros except that they also declare the plumbing
necessary for creating the sequencer's sequence library. This includes:

1. Declaring the type-based static queue of strings registered on the
sequencer type.

2. Declaring the static function to add strings to item #1 above.

3. Declaring the static function to remove strings to item #1 above.

4. Declaring the function to populate the instance specific sequence library
for a sequencer.

Use `uvm_sequencer_utils[_begin] for non-parameterized classes and
`uvm_sequencer_param_utils[_begin] for parameterized classes.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_set_super_type"></a>
					<span class="signature">

	<a name="macro_uvm_set_super_type"></a><b>			`uvm_set_super_type(T, ST)
</b>

					</span>
	<pre class="comment">-----------------------------------------------------------------------------
MACRO: `uvm_set_super_type

| `uvm_set_super_type(T,ST)

Defines the super type of ~T~ to be ~ST~. This allows for derived class
objects to inherit typewide callbacks that are registered with the base
class.

The registration will typically occur in the component that executes the
given type of callback. For instance:

| virtual class mycb extend uvm_callback;
|   virtual function void doit();
| endclass
|
| class my_comp extends uvm_component;
|   `uvm_register_cb(my_comp,mycb)
|   ...
|   task run_phase(uvm_phase phase);
|     ...
|     `uvm_do_callbacks(my_comp, mycb, doit())
|   endtask
| endclass
|
| class my_derived_comp extends my_comp;
|   `uvm_set_super_type(my_derived_comp,my_comp)
|   ...
|   task run_phase(uvm_phase phase);
|     ...
|     `uvm_do_callbacks(my_comp, mycb, doit())
|   endtask
| endclass
-----------------------------------------------------------------------------<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_slave_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_slave_imp_decl"></a><b>			`uvm_slave_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_slave_imp_decl

| `uvm_slave_imp_decl(SFX)

Define the class uvm_slave_impSFX for providing both blocking and
non-blocking slave implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_transport_imp_decl"></a>
					<span class="signature">

	<a name="macro_uvm_transport_imp_decl"></a><b>			`uvm_transport_imp_decl(SFX)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_transport_imp_decl

| `uvm_transport_imp_decl(SFX)

Define the class uvm_transport_impSFX for providing both blocking and
non-blocking transport implementations.  ~SFX~ is the suffix for the new class
type.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_typename"></a>
					<span class="signature">

	<a name="macro_uvm_typename"></a><b>			`uvm_typename(X)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_array"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_array"></a><b>			`uvm_unpack_array(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_array

Unpack a dynamic array without having to also specify the bit size
of its elements. Array size must be non-zero.

| `uvm_unpack_array(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_arrayN"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_arrayN"></a><b>			`uvm_unpack_arrayN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_arrayN

Unpack into a dynamic array of integrals.

| `uvm_unpack_arrayN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_enum"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_enum"></a><b>			`uvm_unpack_enum(VAR, TYPE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_enum

Unpack an enumeration value, which requires its type be specified.

| `uvm_unpack_enum(VAR,TYPE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_enumN"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_enumN"></a><b>			`uvm_unpack_enumN(VAR, SIZE, TYPE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_enumN

Unpack enum of type ~TYPE~ into ~VAR~.

`uvm_unpack_enumN(VAR,SIZE,TYPE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_int"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_int"></a><b>			`uvm_unpack_int(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_int

Unpack an integral variable without having to also specify the bit size.

| `uvm_unpack_int(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_intN"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_intN"></a><b>			`uvm_unpack_intN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_intN

Unpack into an integral variable.

| `uvm_unpack_intN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_queue"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_queue"></a><b>			`uvm_unpack_queue(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_queue

Unpack a queue without having to also specify the bit size
of its elements. Queue must not be empty.

| `uvm_unpack_queue(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_queueN"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_queueN"></a><b>			`uvm_unpack_queueN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_queueN

Unpack into a queue of integrals.

| `uvm_unpack_queue(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_real"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_real"></a><b>			`uvm_unpack_real(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_real

Unpack a variable of type real.

| `uvm_unpack_real(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_sarray"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_sarray"></a><b>			`uvm_unpack_sarray(VAR)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_sarray

Unpack a static array without having to also specify the bit size
of its elements.

| `uvm_unpack_sarray(VAR)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_sarrayN"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_sarrayN"></a><b>			`uvm_unpack_sarrayN(VAR, SIZE)
</b>

					</span>
	<pre class="comment">Macro: `uvm_unpack_sarrayN

Unpack a static (fixed) array of integrals.

| `uvm_unpack_sarrayN(VAR,SIZE)<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_unpack_string"></a>
					<span class="signature">

	<a name="macro_uvm_unpack_string"></a><b>			`uvm_unpack_string(VAR)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_update_sequence_lib"></a>
					<span class="signature">

	<a name="macro_uvm_update_sequence_lib"></a><b>			`uvm_update_sequence_lib
</b>

					</span>
	<pre class="comment">MACRO- `uvm_update_sequence_lib

This macro populates the instance-specific sequence library for a sequencer.
It should be invoked inside the sequencers constructor.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_update_sequence_lib_and_item"></a>
					<span class="signature">

	<a name="macro_uvm_update_sequence_lib_and_item"></a><b>			`uvm_update_sequence_lib_and_item(USER_ITEM)
</b>

					</span>
	<pre class="comment">MACRO- `uvm_update_sequence_lib_and_item

This macro populates the instance specific sequence library for a sequencer,
and it registers the given ~USER_ITEM~ as an instance override for the simple
sequence's item variable.

The macro should be invoked inside the sequencer's constructor.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_user_bottomup_phase"></a>
					<span class="signature">

	<a name="macro_uvm_user_bottomup_phase"></a><b>			`uvm_user_bottomup_phase(PHASE, COMP, PREFIX)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_user_task_phase"></a>
					<span class="signature">

	<a name="macro_uvm_user_task_phase"></a><b>			`uvm_user_task_phase(PHASE, COMP, PREFIX)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_user_topdown_phase"></a>
					<span class="signature">

	<a name="macro_uvm_user_topdown_phase"></a><b>			`uvm_user_topdown_phase(PHASE, COMP, PREFIX)
</b>

					</span>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_warning"></a>
					<span class="signature">

	<a name="macro_uvm_warning"></a><b>			`uvm_warning(ID, MSG)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_warning

| `uvm_warning(ID,MSG)

Calls uvm_report_warning with a verbosity of UVM_NONE. The message can not
be turned off using the reporter's verbosity setting, but can be turned off
by setting the action for the message.  ~ID~ is given as the message tag and
~MSG~ is given as the message text. The file and line are also sent to the
uvm_report_warning call.<br></pre>
				</li>
				<li class="list-group-item">
					<a name="macro_uvm_warning_context"></a>
					<span class="signature">

	<a name="macro_uvm_warning_context"></a><b>			`uvm_warning_context(ID, MSG, CNTXT)
</b>

					</span>
	<pre class="comment">MACRO: `uvm_warning_context

| `uvm_warning_context(ID,MSG,CNTXT)

Operates identically to `uvm_warning but requires that the
context, or <uvm_report_object>, in which the message is printed be
explicitly supplied as a macro argument.<br></pre>
				</li>
		</ul>

	</div>



	</div>

	<div class="footer">
		<hr><p class="text-center">Generated  on Tue Jul 05 17:37:21 EEST 2016 using <a href="http://www.dvteclipse.com/" target="_new">Specador<sup>TM</sup></a> Version 16.1.15</p>
    </div>

	<script src="lib/jquery/js/jquery.js"></script>
	<script src="lib/jquery/js/jquery.scrollUp.js"></script>
	<script src="lib/bootstrap/js/bootstrap.js"></script>
	<script src="lib/svg-pan-zoom/js/svg-pan-zoom.js"></script>
	<script src="js/content.js"></script>
	<script src="js/custom.js"></script>

	</body>
</html>
